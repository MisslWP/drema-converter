# Конкурсное задание по проектно-технологической практике
# DremaConverter + convertio.h
## Автор: Дремин Кирилл, ИУ7-26Б

### Краткое описание
В рамках данного задания представлены два продукта.
Первый - программа-конвертер DremaConverter, поддерживающая T2B и B2T направления конвертации для числовых типов данных.
Второй продукт - лёгкий заголовочный файл *convertio.h*, предоставляющий возможности по автоматической генерации функций T2B и B2T конвертеров для любых пользовательских типов данных.

### DremaConverter

Данная программа предоставляет простой инструментарий по конвертации файлов с текстовыми и бинарными данными. Для проведения конвертации необходимо указать в аргументах программы направление (-t - T2B, -b - B2T), тип используемых данных (-T TYPE) и опционально - выходной файл (-o OUT_FILE), после чего передать путь к конвертируемуму файлу.

Пример выполнения программы:
**T2B**:
```bash
./converter.exe -t -T int -o numbers.bin numbers.txt
```
**B2T**:
```bash
./converter.exe -b -T int -o numbers.txt numbers.bin
```

Также имеется возможность просмотра справки при вызове с ключом -h.

### convertio.h

Заголовочный файл *convertio.h* - это лёгкий в использовании инструмент, позволяющий проводить конвертацию T2B или B2T для заданных типов данных.
Принцип работы данного инструмента заключается в использовании кодогенерации при помощи макросов препроцессора.

Предоставляемые макросы:
| Макрос | Описание |
| ------ | ------ |
| GEN_IO_HEADER(**TYPE**) | Производит предварительное объявление функций конвертации |
| GEN_IO_BODY(**TYPE**, ```const char* ```SCAN_FMT, ```const char*``` PRINT_FMT) | Производит непосредственное определение функций конвертации |
| CONVERT_T2B(**TYPE**, ```FILE*``` in, ```FILE*``` out) | Производит конвертацию заданного текстового файла в заданный бинарный файл |
| CONVERT_B2T(**TYPE**, ```FILE*``` in, ```FILE*``` out, ```char *``` delimeter, ```char *``` end) | Производит конвертацию заданного бинарного файла в заданный текстовый файл, используя строку **delimter** как разделитель, а также добавляя в конце файла строку **end** |

Также в заголовочном файле определены макросы OK = 0 и ERR_READ = -1, значения, возвращаемые функциями-конвертерами могут принимать только одно из этих значений.

Также вместе с заголовочным файлом *convertio.h* поставляются файлы *standart_converts.h* и *standart_converts.c*, содержащие сгенерированные конвертеры для следующих типов данных: ```int, long, int64_t, int32_t, float, double, char```.

Помимо поддержки встроенных в язык Си типов данных *convertio.h* поддерживает T2B и B2T конвертацию любых типов данных, определённых пользователем. Для этого предоставляются следующие макросы:
| Макрос | Описание |
| ------ | ------ |
| GEN_CUSTOM_IO_HEADER(**TYPE**) | Производит предварительное объявление функций конвертации |
| GEN_CUSTOM_IO_BODY(**TYPE**, **DEFAULT**) | Производит непосредственное определение функций конвертации, где DEFAULT - значение по умолчанию для переменной пользовательского типа |
| CUSTOM_CONVERT_T2B(**TYPE**, ```FILE*``` in, ```FILE*``` out, ```int (*```custom_scan```)``` ```(FILE*, TYPE*)```) | Производит конвертацию заданного текстового файла в заданный бинарный файл, используя для чтения функцию custom_scan |
| CUSTOM_CONVERT_B2T(**TYPE**, ```FILE*``` in, ```FILE*``` out, ```void (*```custom_print```)``` ```(FILE*, TYPE*)```, ```char *``` delimeter, ```char *``` end) | Производит конвертацию заданного бинарного файла в заданный текстовый файл, используя строку **delimter** как разделитель, а также добавляя в конце файла строку **end**, используя для вывода функцию custom_print |

### Создание конвертеров собственных типов данных

Рассмотрим создание конвертера собственного типа данных на примере структуры, отображающей студента.
Определим для начала данную структуру:
```c
#define SURNAME_LEN 25
#define NAME_LEN 10
#define MARKS_AMOUNT 4

#define EMPTY_STUDENT {"", "", {0, 0, 0, 0}}

typedef struct student {
    char surname[SURNAME_LEN];
    char name[NAME_LEN];
    uint32_t marks[MARKS_AMOUNT];
} Student;
```

Также нам необходимо объявить следующие функции, совпадающие с заявленной в макросе-генераторе сигнатурой:
```c
void print_student(FILE *stream, Student *st)
{
    fprintf(stream, "%s %s %u %u %u %u", st->name, st->surname, st->marks[0],
            st->marks[1], st->marks[2], st->marks[3]);
}
int scan_student(FILE *stream, Student *st)
{
    return fscanf(stream, "%s %s %u %u %u %u", st->name, st->surname, st->marks,
                  st->marks + 1, st->marks + 2, st->marks + 3);
}
```

Для того, чтобы сгенерировать конвертеры для данной структуры данных в нашей программе разместим следующие строки:
```c
GEN_CUSTOM_IO_HEADER(Student)
GEN_CUSTOM_IO_BODY(Student, EMPTY_STUDENT)
```

###### Примечание
Передача пустого значения студента необходима для корректной инициализации значений при чтении, во избежание записи мусора в бинарный файл

Далее мы можем вызывать конвертеры следующим образом:
```c
CUSTOM_CONVERT_T2B(Student, stdin, file_out, scan_student);
CUSTOM_CONVERT_B2T(Student, file_in, stdout, print_student, " ", "\n");
```

#### Контракты, которые необходимо соблюсти для корректной работы пользовательских конвертеров
1. Пользовательская функция считывания данных должна возвращать значение больше нуля при успешном вводе и иные для неуспешного ввода
2. Пользовательские функции должны удовлетворять следующим сигнатурам, где TYPE - тип данных.
    Функция сканирования:
    ```c
    int scan_some(FILE *stream, TYPE *type_obj);
    ```
    Функция печати:

    ```c
    void print_some(FILE *stream, TYPE *type_obj);
    ```

### Подробности по работе с convertio.h

1. Макросы-генераторы создают функции с названиями convert_TYPE_t2b(FILE *in, FILE *out) и convrt_TYPE_b2t(FILE *in, FILE *out, char *delimeter, char *end) и их версии с префиксом *custom_*, однако их непосредственное использование не рекомендуется, так как данные наименования могут быть изменены. В рамках контракта гарантируется, что вызов CONVERT_T2B и CONVERT_B2T (А также их версий с префиксом *CUSTOM_*) будет раскрыт в корректный вызов функции
2. При генерации собственных конвертеров необходимо предоставлять название типа, не содержащее пробелов, т.е. типы, такие как ```unsigned long long``` или ```signed char``` требуется предоставить синонимы, созданные при помощи typedef (например ```ull_t``` и ```schar_t```)
3. Также при создании собственных конвертеров необходимо учесть, что из-за требования о передаче значения по-умолчанию для данного типа будет затруднено использование конвертеров с типами данных, имеющими внутри аттрибут const, поскольку запись в такие поля не сможет быть произведена и компилятор выдаст предупреждение
4. Поскольку предоставляемые функции не имеют проверок валидности открытия файлов, необходимо всегда передавать корректно открытые файлы с корректными спецификаторами доступа, приведёнными в таблице:

    |  | in | out |
    | --- | --- | ---- |
    | T2B | "r" | "wb" |
    | B2T | "rb" | "w" |


### Подробности технической реализации convertio.h

Фактически данный заголовочный файл предоставляет макросы, обеспечивающие генерацию простых функций конвертации.

Рассмотрим примеры функций T2B и B2T конвертации для типа float:
```c
int convert_float_t2b(FILE *in, FILE *out)
{
    float cur;
    int scan_code;
    while ((scan_code = fscanf(in, "%f", &cur)) == 1)
    {
        fwrite(&cur, sizeof(float), 1, out);
    }
    return scan_code == -1 ? 0 : -1;
}
```
Принцип работы данной функции довольно прост. В объявленную переменную типа float происходит считывание значений при помощи fscanf, а далее непосредственно запись в бинарный файл.
```c
int convert_float_b2t(FILE *in, FILE *out, char *delimeter, char *end)
{
    float cur;
    if (fread(&cur, sizeof(float), 1, in) == 1)
    {
        fprintf(out, "%f", cur);
        while (fread(&cur, sizeof(float), 1, in) == 1)
        {
            fprintf(out, "%s", delimeter);
            fprintf(out, "%f", cur);
        }
        fprintf(out, "%s", end);
    }
    char c;
    return fread(&c, sizeof(char), 1, in) == 0 ? 0 : -1;
}
```
Данная функция устроена аналогично с учётом необходимости учесть разделители между выводимыми файлами - происходит считывание байтов в переменную, а далее - её вывод, после чего выводится разделитель и следующее значение, пока они не закончатся, после чего - терминирующая строка.
Успешность операции вывода осуществляется путём попытки считать один байт. В случае успеха можно прийти к выводу, что в файле остались ещё данные, что свидетельствует об ошибке.

Аналогичные функции для пользовательских типов данных устроены практически так же, за исключением замены функций fscanf и fprintf на передаваемые пользовательские функции, так что их описание приведено не будет.

